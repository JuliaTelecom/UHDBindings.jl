var documenterSearchIndex = {"docs":
[{"location":"base/#Common-functions-and-Configurations","page":"Function list","title":"Common functions and Configurations","text":"","category":"section"},{"location":"base/","page":"Function list","title":"Function list","text":"Modules = [UHDBindings]\nPages   = [\"UHDBindings.jl\"]\nOrder   = [:function, :type]\nDepth\t= 1","category":"page"},{"location":"base/#Base.close-Tuple{UHDBinding}","page":"Function list","title":"Base.close","text":"Close the USRP device (Rx or Tx mode) and release all associated objects\n\n–- Syntax\n\nclose(uhd)\n\n–- Input parameters\n\nuhd\t: UHD object [UHDBinding]\n\n–- Output parameters\n\n[]\n\n\n\n\n\n","category":"method"},{"location":"base/#Base.print","page":"Function list","title":"Base.print","text":"Print the radio configuration \n\n–- Syntax\n\nprint(radio,chan=0)\n\n–- Input parameters\n\nradio\t\t: UHD object [Union{UHDBinding,UHDTx,UHDRx}]\nchan : Channel index to display (default 0)\n\n–- Output parameters\n\n[]\n\n\n\n\n\n","category":"function"},{"location":"base/#UHDBindings.getBufferSize-Tuple{Any}","page":"Function list","title":"UHDBindings.getBufferSize","text":"\"  Returns the  internal radio buffer size \n\n\n\n\n\n","category":"method"},{"location":"base/#UHDBindings.openUHD-Tuple{Any, Any, Any}","page":"Function list","title":"UHDBindings.openUHD","text":"Init the core parameter of the radio in Tx or in Rx mode and initiate RF parameters \n\n–- Syntax\n\nopenUHD(mode,sysImage,carrierFreq,samplingRate,txGain,antenna=\"RX2\")\n\n–- Input parameters\n\nmode \t\t\t: String to open radio in \"Tx\" (transmitter) or in \"Rx\" (receive) mode\ncarrierFreq\t: Desired Carrier frequency [Union{Int,Float64}] \nsamplingRate\t: Desired bandwidth [Union{Int,Float64}] \ngain\t\t: Desired Gain [Union{Int,Float64}] \nantenna\t\t: Desired Antenna alias Dict{Symbol,Vector[String]} (e.g. Dict(:Rx=>[\"RX2\"],:Tx=>[\"TRX\"]))\n\nKeywords=\n\nargs\t  : String with the additionnal load parameters (for instance, path to the FPHGA image) [String]\n\n–- Output parameters\n\nuhd\t\t  \t: UHD object [UHDBinding]\n\n\n\n\n\n","category":"method"},{"location":"base/#UHDBindings.set_lib_path-Tuple{String}","page":"Function list","title":"UHDBindings.set_lib_path","text":"Set the path for the UHD shared library (e.g /Documents/Program/UHD/libuhd.dll or /opt/local/uhd/uhd.lib\") Usefull for custom installation without messing up the PATHs Example= setlibpath(\"C://Program/UHD/bin/libUHD.dll\")\n\n\n\n\n\n","category":"method"},{"location":"base/#UHDBindings.set_provider-Tuple{String}","page":"Function list","title":"UHDBindings.set_provider","text":"Change UHD driver provider. Support \"yggdrasil\" to use shipped jll file or \"local\" to use custom installed library setprovider(\"yggdrasil\") or  setprovider(\"local\")\n\n\n\n\n\n","category":"method"},{"location":"base/#UHDBindings.updateCarrierFreq!","page":"Function list","title":"UHDBindings.updateCarrierFreq!","text":"Update carrier frequency of current radio device, and update radio object with the new obtained carrier frequency. If the input parameter is the UHDBinding object, the desired carrier frequency will be applied on both Rx and Tx sides.  If the input is a [UHDRx] or a [UHDTx] object, it updates only the Rx or Tx carrier frequency   \n\n–- Syntax\n\nupdateCarrierFreq!(radio,carrierFreq)\n\n–- Input parameters\n\nradio\t  : UHD device [Union{UHDBinding,UHDRx,UHDTx}]\ncarrierFreq\t: New desired carrier frequency \nchan : Channel index to use (default 0)\n\n–- Output parameters\n\n\n\n\n\n\n\n","category":"function"},{"location":"base/#UHDBindings.updateGain!","page":"Function list","title":"UHDBindings.updateGain!","text":"Update gain of current radio device, and update radio object with the new obtained gain. If the input parameter is the UHDBinding object, the desired gain will be applied on both Rx and Tx sides.  If the input is a [UHDRx] or a [UHDTx] object, it updates only the Rx or Tx gain   \n\n–- Syntax\n\nupdateGain!(radio,gain)\n\n–- Input parameters\n\nradio\t  : UHD device [Union{UHDBinding,UHDRx,UHDTx}]\ngain\t: New desired gain \nchan : Channel index to use (default 0)\n\n–- Output parameters\n\n\n\n\n\n\n\n","category":"function"},{"location":"base/#UHDBindings.updateSamplingRate!","page":"Function list","title":"UHDBindings.updateSamplingRate!","text":"Update sampling rate of current radio device, and update radio object with the new obtained sampling frequency. If the input parameter is the UHDBinding object, the desired sampling frequency will be applied on both Rx and Tx sides.  If the input is a [UHDRx] or a [UHDTx] object, it updates only the Rx or Tx sampling frequency   \n\n–- Syntax\n\nupdateSamplingRate!(radio,samplingRate,chan=0)\n\n–- Input parameters\n\nradio\t  : UHD device [Union{UHDBinding,UHDRx,UHDTx}]\nsamplingRate\t: New desired sampling rate \nchan : Channel index to use (default 0)\n\n–- Output parameters\n\n\n\n\n\n\n\n","category":"function"},{"location":"base/#Receiver-functions","page":"Function list","title":"Receiver functions","text":"","category":"section"},{"location":"base/","page":"Function list","title":"Function list","text":"Modules = [UHDBindings]\nPages   = [\"Rx.jl\"]\nOrder   = [:function, :type]\nDepth\t= 1","category":"page"},{"location":"base/#UHDBindings.getError-Tuple{UHDRx}","page":"Function list","title":"UHDBindings.getError","text":"Returns the Error flag of the current UHD burst \n\n–- Syntax\n\nflag = getError(radio)\n\n–- Input parameters\n\nradio : UHD object [UHDRx]\n\n–- Output parameters\n\nerr\t: Error Flag [errorcodet]\n\n\n\n\n\n","category":"method"},{"location":"base/#UHDBindings.getTimestamp-Tuple{UHDRx}","page":"Function list","title":"UHDBindings.getTimestamp","text":"Return the timestamp of the last UHD burst \n\n–- Syntax\n\n(second,fracSecond) = getTimestamp(radio)\n\n–- Input parameters\n\nradio\t  : UHD UHD object [UHDRx]\n\n–- Output parameters\n\nsecond  : Second value for the flag [Int]\nfracSecond : Fractional second value [Float64]\n\n\n\n\n\n","category":"method"},{"location":"base/#UHDBindings.populateBuffer!","page":"Function list","title":"UHDBindings.populateBuffer!","text":"Calling UHD function wrapper to fill a buffer. It is preferable to cal this function though the use of recv or recv!\n\n–- Syntax\n\nrecv!(sig,radio,nbSamples)\n\n–- Input parameters\n\nradio\t  \t: UHD object [UHDRx]\nptr  \t\t: Writable memory position [Ref{Ptr{Cvoid}}]\nnbSamples : Number of samples to acquire \n\n–- Output parameters\n\nnbSamp \t: Number of samples fill in buffer [Csize_t]\n\n\n\n\n\n","category":"function"},{"location":"base/#UHDBindings.recv!-Union{Tuple{T}, Tuple{Array{Array{Complex{T}, 1}, 1}, UHDRx}} where T","page":"Function list","title":"UHDBindings.recv!","text":"Get a single buffer from the USRP device, using the Buffer structure \n\n–- Syntax\n\nrecv!(sig,radio,nbSamples)\n\n–- Input parameters\n\nsig\t  : Complex signal to populate [Array{Complex{Cfloat}}]\nradio\t  : UHD object [UHDRx]\nbuffer  : Buffer object (obtained with setBuffer(radio)) [Buffer] \n\n–- Output parameters\n\n\n\n\n\n\n\n","category":"method"},{"location":"base/#UHDBindings.recv-Tuple{UHDRx, Any}","page":"Function list","title":"UHDBindings.recv","text":"Get a single buffer from the USRP device, and create all the necessary ressources\n\n–- Syntax\n\nsig\t  = recv(radio,nbSamples)\n\n–- Input parameters\n\nradio\t  : UHD object [UHDRx]\nnbSamples : Desired number of samples [Int]\n\n–- Output parameters\n\nsig\t  : baseband signal from radio [Array{Complex{CFloat}},radio.packetSize]\n\n\n\n\n\n","category":"method"},{"location":"base/#UHDBindings.restartStreamer-Tuple{UHDRx}","page":"Function list","title":"UHDBindings.restartStreamer","text":"Restart the USRP streamer. In some cases (especially macOS) we have an issue with streamer congestion and we need to restart it.  By now, we have added the restart function in recv! method.\n\n\n\n\n\n","category":"method"},{"location":"base/#UHDBindings.uhd_usrp_create_stream-Tuple{UHDRx}","page":"Function list","title":"UHDBindings.uhd_usrp_create_stream","text":"Create and launch a streamer with dedicated parameters \n\n\n\n\n\n","category":"method"},{"location":"base/#Transmitter-functions","page":"Function list","title":"Transmitter functions","text":"","category":"section"},{"location":"base/","page":"Function list","title":"Function list","text":"Modules = [UHDBindings]\nPages   = [\"Tx.jl\"]\nOrder   = [:function, :type]\nDepth\t= 1","category":"page"},{"location":"base/#UHDBindings.send","page":"Function list","title":"UHDBindings.send","text":"Send a buffer though the radio device. It is possible to force a cyclic buffer send (the radio uninterruply send the same buffer) by setting the cyclic parameter to true\n\n–- Syntax\n\nsend(radio,buffer,cyclic=false)\n\n–- Input parameters\n\nradio\t  \t: UHD device [UHDRx]\nbuffer \t: Buffer to be send [Union{Array{Complex{Cfloat}},Array{Cfloat}}] \ncyclic \t: Send same buffer multiple times (default false) [Bool]\n\n–- Output parameters\n\nnbEch \t: Number of samples effectively send [Csize_t]. It corresponds to the number of complex samples sent.\n\n\n\n\n\n","category":"function"},{"location":"use_libuhd/#Low-level-API","page":"Custom use of LibUHD","title":"Low level API","text":"","category":"section"},{"location":"use_libuhd/","page":"Custom use of LibUHD","title":"Custom use of LibUHD","text":"The functions provided by UHDBindings covers two aspects: the high level API (with Julia calls and structures) and the low level API, which consists of the C functions provided by UHD. The bindings, generated by Clang.jl are not directly exported by UHDBindings but the functions can be used with ","category":"page"},{"location":"use_libuhd/","page":"Custom use of LibUHD","title":"Custom use of LibUHD","text":"    # High level call \n    using UHDBindings\n    radio = openUHD(700e6,4e6,50;nbAntennaRx=1,nbAntennaTx=1)\n    # Low level call\n    import UHDBindings.LibUHD as LibUHD\n    LibUHD.uhd_usrp_....()","category":"page"},{"location":"use_libuhd/","page":"Custom use of LibUHD","title":"Custom use of LibUHD","text":"In this case, it is necessary to align the parameters with the one requested by UHD. Thus ","category":"page"},{"location":"use_libuhd/","page":"Custom use of LibUHD","title":"Custom use of LibUHD","text":"To the get output parameters, it is necessary to define beforehand a Reference with the appropriate type and then deference the ref to get the value  \nuhd functions often request parameters defined in the top structure layer of UHDBindings. \nh which is an uhd_usrp_handle is defined in radio.rx.uhd.pointerUSRP or radio.tx.uhd.pointerUSRP\nStreamer operations require uhd_rx_streamer_handle, which is in our structure radio.rx.uhd.pointerStreamer\nMetadata operation uses uhd_rx_metadata_handle (present by deferencing radio.rx.uhd.addressMD[]) and uhd_tx_metadata_handle (present by deferencing radio.tx.uhd.addressMD[])\nchan corresponds to the index of the used channel. Be default (in SISO) it is 0\nThe uhd_tune_request calls are a little tricky and a Ref of the aligned Julia structure uhd_tune_requestshould be used. An example is given in the Julia function updateCarrierFreq! ","category":"page"},{"location":"use_libuhd/","page":"Custom use of LibUHD","title":"Custom use of LibUHD","text":"For instance, to manually get the Rx gain and set up the gain without using updateGain! ","category":"page"},{"location":"use_libuhd/","page":"Custom use of LibUHD","title":"Custom use of LibUHD","text":"    # High level call \n    using UHDBindings\n    radio = openUHD(700e6,4e6,50;nbAntennaRx=1,nbAntennaTx=1)\n    # Low level call\n    import UHDBindings.LibUHD as LibUHD\n    res = Ref{Cdouble}(0) # Define a ref to store the result, should be aligned with type in C UHD function. \n    LibUHD.uhd_usrp_get_rx_gain(radio.rx.uhd.pointerUSRP,0,\"\",res)\n    println(\"The gain is $(res[])\") # using res[] to deference the ref and get the value of the gain","category":"page"},{"location":"use_libuhd/","page":"Custom use of LibUHD","title":"Custom use of LibUHD","text":"This low level calls can, be useful (and necessary) to define specific radio configurations and handle scenarios not supported by UHDBindings. This is for example the case of the following example that redefines all the layer to support MIMO. Note that this can be done by initiating openUHD with nbAntennaRx=2.","category":"page"},{"location":"use_libuhd/","page":"Custom use of LibUHD","title":"Custom use of LibUHD","text":"# ----------------------------------------------------\n# --- Load packages\n# ---------------------------------------------------- \nusing UHDBindings \nimport UHDBindings.LibUHD as LibUHD\nimport UHDBindings.initRxUHD\nimport UHDBindings.@assert_uhd\n\n# ----------------------------------------------------\n# --- Parameters \n# ---------------------------------------------------- \ncarrierFreq = 868e6\nsamplingRate= 2e6\ngain        = 25\nuhdArgs     = \"\"\nnbAntennaRx = 2\n\n# ---------------------------------------------------- \n# --- Create radio \n# ---------------------------------------------------- \n# --- Open radio, in MIMO mode \n# Note the warning about the streamer. It can not be set in MIMO mode \n# The configuration will be updated later, and most of the parameters overwritten\n# To ensure we have what we want, we need to bypass the streamer, and deactivate all antennas\nradio = openUHD(carrierFreq,samplingRate,gain;nbAntennaRx=0,nbAntennaTx=0,bypassStreamer = true)\n\n# ----------------------------------------------------\n# --- Set up Radio \n# ---------------------------------------------------- \n# --- Channels  & Antenna \nchannelIndexes = [0,1]\nantennas       = [\"TX/RX\",\"RX2\"]\n# --- Streamer arguments\na1\t\t\t   =  Base.unsafe_convert(Cstring,\"fc32\");\na2\t\t\t   =  Base.unsafe_convert(Cstring,\"sc16\");\na3\t\t\t   =  Base.unsafe_convert(Cstring,uhdArgs);\nchannel        = pointer(channelIndexes)\nuhdArgs_0\t   = LibUHD.uhd_stream_args_t(a1,a2,a3,channel,nbAntennaRx);\n# --- RF Configuration \nfor (c,currChan) in enumerate(channelIndexes[1:nbAntennaRx])\n    # Set the carrier frequencies \n    updateCarrierFreq!(radio.rx,carrierFreq,currChan)\n    # Set the sampling rate \n    updateSamplingRate!(radio.rx,samplingRate,currChan)\n    # Set the gains \n    updateGain!(radio.rx,gain,currChan)\n    # Set the antennas\n    LibUHD.uhd_usrp_set_rx_antenna(radio.rx.uhd.pointerUSRP,antennas[c],currChan)\nend\n# --- Subdev with 2 boards\npointerSubDev = Ref{LibUHD.uhd_subdev_spec_handle}()\n@assert_uhd LibUHD.uhd_subdev_spec_make(pointerSubDev,\"A:0 A:1\")\n@assert_uhd LibUHD.uhd_usrp_set_rx_subdev_spec(radio.rx.uhd.pointerUSRP,pointerSubDev[],0)\nLibUHD.uhd_subdev_spec_free(pointerSubDev)\n# --- Internal streamer and buffer config\npointerArgs\t  = Ref{LibUHD.uhd_stream_args_t}(uhdArgs_0);\npointerSamples = Ref{Csize_t}(0);\n@assert_uhd LibUHD.uhd_usrp_get_rx_stream(radio.rx.uhd.pointerUSRP,pointerArgs,radio.rx.uhd.pointerStreamer)\n@assert_uhd LibUHD.uhd_rx_streamer_max_num_samps(radio.rx.uhd.pointerStreamer,pointerSamples)\nprintln(\"Internal buffer size is $(pointerSamples[])\")\nradio.rx.packetSize= pointerSamples[]\n# --- Clock source \n@assert_uhd LibUHD.uhd_usrp_set_clock_source(radio.rx.uhd.pointerUSRP,\"internal\",0)\n@assert_uhd LibUHD.uhd_usrp_set_time_now(radio.rx.uhd.pointerUSRP,0,0,0)\n\n# ----------------------------------------------------\n# --- Set up streamer \n# ---------------------------------------------------- \nstreamCmd\t= UHDBindings.uhd_stream_cmd_t(UHDBindings.UHD_STREAM_MODE_NUM_SAMPS_AND_MORE,radio.rx.packetSize*10_000,false,1,0.5);\npointerCmd\t= Ref{UHDBindings.uhd_stream_cmd_t}(streamCmd);\nLibUHD.uhd_rx_streamer_issue_stream_cmd(radio.rx.uhd.pointerStreamer,pointerCmd)\nsleep(0.1)\n# ---------------------------------------------------- \n# --- Julia buffers \n# ---------------------------------------------------- \t\n# Define an array to get all the buffers from all the channels \nnbSamples             = getBufferSize(radio)\nsig                   = [zeros(Complex{Cfloat},radio.rx.packetSize) for n ∈ 1:nbAntennaRx]\nlistBuffer            = [pointer(sig[n],1) for n ∈ 1 : nbAntennaRx]\nptr                   = listBuffer\npointerCounterSamples = Ref{Csize_t}(0);\n\n# ----------------------------------------------------\n# --- Receive data \n# ---------------------------------------------------- \npointerCounterSamples = Ref{Csize_t}(0);\nLibUHD.uhd_rx_streamer_recv(radio.rx.uhd.pointerStreamer,ptr,nbSamples,radio.rx.uhd.addressMD,1.6,true,pointerCounterSamples)\nnbReceivedSamples = pointerCounterSamples[]\nprintln(\"Receive $nbReceivedSamples samples\")\n\n# ----------------------------------------------------\n# --- Second call \n# ---------------------------------------------------- \naccum = 0\nfor iN = 1 : 1 : 10_000\n    pointerCounterSamples = Ref{Csize_t}(0);\n    LibUHD.uhd_rx_streamer_recv(radio.rx.uhd.pointerStreamer,ptr,nbSamples,radio.rx.uhd.addressMD,0,true,pointerCounterSamples)\n    nbReceivedSamples = pointerCounterSamples[]\n    global accum += nbReceivedSamples\nend\nprintln(\"End of transmission, received $accum samples\")\n# ----------------------------------------------------\n# --- Close \n# ---------------------------------------------------- \nclose(radio)","category":"page"},{"location":"Examples/example_parameters/#Update-parameters-of-the-radio","page":"Update parameters of the radio","title":"Update parameters of the radio","text":"","category":"section"},{"location":"Examples/example_parameters/","page":"Update parameters of the radio","title":"Update parameters of the radio","text":"It is possible to update the radio parameter such as the gain, the bandwidth and the sampling rate.  In this function, we change the carrier frequency to 2400MHz, the bandwidth from 16MHz to 100MHz and the Rx gain from 10 to 30dB. In some cases, the desired parameters cannot be obtained. In such a case, we let UHD decide what is the most appropriate value. A warning is raised and the output of the functions used to change the  the radio parameters corresponds to the effective values of the radio. ","category":"page"},{"location":"Examples/example_parameters/","page":"Update parameters of the radio","title":"Update parameters of the radio","text":"function main()\n\t# ---------------------------------------------------- \n\t# --- Physical layer and RF parameters \n\t# ---------------------------------------------------- \n\tcarrierFreq\t= 868e6; \t# --- The carrier frequency (Hz)\t\n\tsamplingRate\t= 16e6;         # --- Targeted bandwidth (Hz)\n\trxGain\t\t= 30.0;         # --- Rx gain (dB)\n\tnbSamples\t= 4096;         # --- Desired number of samples\n\n\t# ---------------------------------------------------- \n\t# --- Getting all system with function calls  \n\t# ---------------------------------------------------- \n\t# --- Creating the radio resource \n\t# The first parameter is for specific parameter (FPGA bitstream, IP address)\n\tradio\t= openUHD(carrierFreq,samplingRate,rxGain);\n\t# --- Display the current radio configuration\n\tprint(radio);\n\t# --- We what to change the parameters ! \n\tupdateSamplingFreq!(radio,100e6);\n\tupdateCarrierFreq!(radio,2400e6);\n\tupdateGain!(radio,30)\n\t# --- Print the new radio configuration \n\tprint(radio);\n\t# --- Release the radio resources\n\tclose(radio); \nend","category":"page"},{"location":"Examples/example_benchmark/#Benchmark-for-Rx-link","page":"Benchmark for Rx link","title":"Benchmark for Rx link","text":"","category":"section"},{"location":"Examples/example_benchmark/","page":"Benchmark for Rx link","title":"Benchmark for Rx link","text":"The following script allows to benchmark the effective rate from the receiver. To do so we compute the number of samples received in a given time. The timing is measured fro the timestamp obtained from the radio. ","category":"page"},{"location":"Examples/example_benchmark/","page":"Benchmark for Rx link","title":"Benchmark for Rx link","text":"module Benchmark \n# ---------------------------------------------------- \n# --- Modules & Utils\n# ---------------------------------------------------- \n# --- External modules \nusing UHDBindings \n# --- Functions \n\"\"\"\nCalculate rate based on UHD timestamp\n\"\"\"\nfunction getRate(tInit,tFinal,nbSamples)\n\tsDeb = tInit.intPart + tInit.fracPart;\n\tsFin = tFinal.intPart + tFinal.fracPart; \n\ttiming = sFin - sDeb; \n\treturn nbSamples / timing;\nend\n\"\"\"\nMain call to monitor Rx rate\n\"\"\"\nfunction main(samplingRate)\t\n\t# ---------------------------------------------------- \n\t# --- Physical layer and RF parameters \n\t# ---------------------------------------------------- \n\t# --- Create the radio object in function\n\tcarrierFreq\t\t= 770e6;\t\t\n\tgain\t\t\t= 50.0; \n\tradio\t\t\t= openUHD(carrierFreq,samplingRate,gain); \n\t# --- Print the configuration\n\tprint(radio);\n\t# --- Init parameters \n\t# Get the radio size for buffer pre-allocation\n\tnbSamples \t\t= radio.packetSize;\n\t# We will get complex samples from recv! method\n\tsig\t\t  = zeros(Complex{Cfloat},nbSamples); \n\t# --- Targeting 2 seconds acquisition\n\t# Init counter increment\n\tnS\t\t  = 0;\n\t# Max counter definition\n\tnbBuffer  = 2*samplingRate;\n\t# --- Timestamp init \n\tp \t\t\t= recv!(sig,radio);\n\tnS\t\t\t+= p;\n\ttimeInit  \t= Timestamp(getTimestamp(radio)...);\n\twhile true\n\t\t# --- Direct call to avoid allocation \n\t\tp = recv!(sig,radio);\n\t\t# --- Ensure packet is OK\n\t\terr \t= getError(radio);\n\t\t# --- Update counter\n\t\tnS\t\t+= p;\n\t\t# --- Interruption \n\t\tif nS > nbBuffer\n\t\t\tbreak \n\t\tend\n\tend\n\t# --- Last timeStamp and rate \n\ttimeFinal = Timestamp(getTimestamp(radio)...);\n\t# --- Getting effective rate \n\tradioRate\t  = radio.samplingRate;\n    effectiveRate = getRate(timeInit,timeFinal,nS);\n\t# --- Free all and return\n\tclose(radio);\n\treturn (radioRate,effectiveRate);\n    end\nend","category":"page"},{"location":"#UHDBindings.jl","page":"Introduction to UHDBindings","title":"UHDBindings.jl","text":"","category":"section"},{"location":"#Purpose","page":"Introduction to UHDBindings","title":"Purpose","text":"","category":"section"},{"location":"","page":"Introduction to UHDBindings","title":"Introduction to UHDBindings","text":"This simple package proposes some bindings to the UHD, the C driver of the Universal Software Radio Peripheral USRP ","category":"page"},{"location":"","page":"Introduction to UHDBindings","title":"Introduction to UHDBindings","text":"The package is heavily dependent on libUHD the open source driver from Ettus research. The library is shipped in the package through Artifacts, and the current implementation uses libUHD.4.0.0","category":"page"},{"location":"","page":"Introduction to UHDBindings","title":"Introduction to UHDBindings","text":"The purpose is to able to instantiate the radio peripheral inside a Julia session and to be able to send and receive complex samples directly within a Julia session. ","category":"page"},{"location":"","page":"Introduction to UHDBindings","title":"Introduction to UHDBindings","text":"The package introduces the UHDBinding structure which pilots and controls the radio. This structure has two important fields namely tx and rx that are respectively related to transmitter and receiver stages. The function can takes UHDBinding as input parameter or UHDBinding.rx,UHDBinding.tx. In the latter case, the configuration will be set to both Tx and Rx stages.","category":"page"},{"location":"#Installation","page":"Introduction to UHDBindings","title":"Installation","text":"","category":"section"},{"location":"","page":"Introduction to UHDBindings","title":"Introduction to UHDBindings","text":"The package can be installed with the Julia package manager. From the Julia REPL, type ] to enter the Pkg REPL mode and run:","category":"page"},{"location":"","page":"Introduction to UHDBindings","title":"Introduction to UHDBindings","text":"pkg> add UHDBindings","category":"page"},{"location":"","page":"Introduction to UHDBindings","title":"Introduction to UHDBindings","text":"Or, equivalently, via the Pkg API:","category":"page"},{"location":"","page":"Introduction to UHDBindings","title":"Introduction to UHDBindings","text":"julia> import Pkg; Pkg.add(\"UHDBindings","category":"page"},{"location":"#Documentation","page":"Introduction to UHDBindings","title":"Documentation","text":"","category":"section"},{"location":"","page":"Introduction to UHDBindings","title":"Introduction to UHDBindings","text":"The base documentation with the different functions can be found in the base section\nDifferent examples are described in in the example section. Other examples are provided in the example subfolder of the project. ","category":"page"},{"location":"#Project-updates-highlights","page":"Introduction to UHDBindings","title":"Project updates highlights","text":"","category":"section"},{"location":"#Version-0.3","page":"Introduction to UHDBindings","title":"Version 0.3","text":"","category":"section"},{"location":"","page":"Introduction to UHDBindings","title":"Introduction to UHDBindings","text":"LibUHD refactor. Bindings have been generated with Clang.jl. It is possible to use a custom configuration after initialize the radio with openUHD. See the MIMO example \nAPI update ! We now support natively multiple boards and MIMO. ","category":"page"},{"location":"#Version-0.2.2","page":"Introduction to UHDBindings","title":"Version 0.2.2","text":"","category":"section"},{"location":"","page":"Introduction to UHDBindings","title":"Introduction to UHDBindings","text":"The UHD lib is now automatically provided by Yggdrasil ! \nIt is still possible to use a custom local UHD installation with the use of Preferences.jl by setting UHDBindings.set_provider(\"local\")","category":"page"},{"location":"#Version-0.2","page":"Introduction to UHDBindings","title":"Version 0.2","text":"","category":"section"},{"location":"","page":"Introduction to UHDBindings","title":"Introduction to UHDBindings","text":"Switch to UHD with version 4.0 with artifact ","category":"page"},{"location":"Examples/example_setup/#Set-up-a-Radio-Link-and-get-some-samples","page":"Set up a Radio Link and get some samples","title":"Set up a Radio Link and get some samples","text":"","category":"section"},{"location":"Examples/example_setup/","page":"Set up a Radio Link and get some samples","title":"Set up a Radio Link and get some samples","text":"In order to get 4096 samples at 868MHz with a instantaneous bandwidth of 16MHz, with a 30dB Rx Gain, the following Julia code should do the trick. ","category":"page"},{"location":"Examples/example_setup/","page":"Set up a Radio Link and get some samples","title":"Set up a Radio Link and get some samples","text":"function main()\n\t# ---------------------------------------------------- \n\t# --- Physical layer and RF parameters \n\t# ---------------------------------------------------- \n\tcarrierFreq\t= 868e6; \t# --- The carrier frequency (Hz)\t\n\tsamplingRate\t= 16e6;         # --- Targeted bandwidth (Hz)\n\trxGain\t\t= 30.0;         # --- Rx gain (dB)\n\tnbSamples\t= 4096;         # --- Desired number of samples\n\n\t# ---------------------------------------------------- \n\t# --- Getting all system with function calls  \n\t# ---------------------------------------------------- \n\t# --- Creating the radio resource \n\t# The first parameter is for specific parameter (FPGA bitstream, IP address)\n\tradio\t= openUHD(carrierFreq,samplingRate,rxGain);\n\t# --- Display the current radio configuration\n\tprint(radio);\n\t# --- Getting a buffer from the radio \n\tsigAll\t= recv(radio,nbSamples);\n\t# --- Release the radio resources\n\tclose(radio); \nend","category":"page"}]
}
